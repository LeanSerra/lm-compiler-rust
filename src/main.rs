use rustemo::Parser;
use std::{path::PathBuf, sync::OnceLock};
use thiserror::Error;

// This will ignore lex.rs file as it is autogenerated by rflex
#[rustfmt::skip]
#[allow(clippy::all)]
mod lex;

// This will ignore grammar.rs file as it is autogenerated by rustemo
#[rustfmt::skip]
#[allow(clippy::all)]
#[allow(warnings)]
mod grammar;
// This will ignore grammar_actions.rs file as it is autogenerated by rustemo
#[rustfmt::skip]
#[allow(clippy::all)]
#[allow(warnings)]
mod grammar_actions;

mod grammar_lexer;

#[derive(Debug, Error)]
enum CompilerError {
    #[error("ParsingError {0:?}")]
    ParserError(rustemo::Error),
}

static OUTPUT_FILE: OnceLock<String> = OnceLock::new();

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let input_path =
        PathBuf::from(OUTPUT_FILE.get_or_init(|| String::from("./examples/hello_world.lm")));

    let program = grammar::GrammarParser::new(grammar_lexer::LexerAdapter::new())
        .parse(&std::fs::read_to_string(input_path).unwrap())
        .map_err(CompilerError::ParserError)?;

    dbg!(program);

    Ok(())
}
