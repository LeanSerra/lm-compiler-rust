// This will ignore lex.rs file as it is autogenerated by rflex
#[rustfmt::skip]
mod lex;

use crate::lex::*;
use std::path::PathBuf;
use thiserror::Error;

#[derive(Debug, Error)]
enum ParserError {
    #[error("ParserError: GetToken {0:?}")]
    GetToken(Error),
    #[error("ParserError: FileSystem error {0}")]
    FileSystem(#[from] std::io::Error),
}

struct Parser<'a> {
    lexer: Lexer<'a>,
}

impl<'a> Parser<'a> {
    fn new(input_path: &mut PathBuf, source: &'a str) -> Result<Self, ParserError> {
        // Create source_code.lexer file to store lexer output
        input_path.set_extension("lexer");
        let lexer_output = std::fs::File::create(&input_path).map_err(ParserError::FileSystem)?;
        // Create lexer
        let lexer = Lexer::new(source, lexer_output);
        Ok(Self { lexer })
    }

    fn get_token(&mut self) -> Result<Token, ParserError> {
        self.lexer.yylex().map_err(ParserError::GetToken)
    }

    fn read_source_code_to_string(input_path: &PathBuf) -> Result<String, ParserError> {
        // Read source code file
        std::fs::read_to_string(input_path).map_err(ParserError::FileSystem)
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut input_path = PathBuf::from("./examples/hello_world.lm");
    let source_code = Parser::read_source_code_to_string(&input_path)?;
    let mut parser = Parser::new(&mut input_path, &source_code)?;

    while let Ok(token) = parser.get_token() {
        dbg!(token);
    }

    Ok(())
}
